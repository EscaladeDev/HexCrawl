
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Hex Explorer ‚Äì v4.1 (tidy)</title>
<style>
  :root{color-scheme:light dark; --bg1:#0b0b0e; --bg2:#151518; --fg:#f5f6f9; --fg-dim:#9aa0a6;
        --card:#0e0e12cc; --border:#26262c; --accent:#6366f1; --ink:#fff; --danger:#ef4444; --ok:#22c55e}
  html,body{height:100%}
  body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,"Noto Sans",sans-serif;
       background:var(--bg2); color:var(--fg)}
  .container{max-width:1320px;margin:0 auto;padding:20px 24px}
  @media (max-width: 1200px){ .container{padding:16px} }
  h1{margin:0 0 4px;font-size:28px;font-weight:800;letter-spacing:-0.02em}
  .sub{color:var(--fg-dim);font-size:14px;margin:0 0 16px}
  .row{display:grid;grid-template-columns:1fr;gap:16px;align-items:start}
  @media (min-width:1200px){.row{grid-template-columns:400px 1fr}}
  .card{background:rgba(18,18,22,.7);backdrop-filter:saturate(1.15) blur(6px);border:1px solid rgba(255,255,255,.06);border-radius:18px;padding:16px;box-shadow:0 8px 30px rgba(0,0,0,.25)}
  .btn{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);padding:8px 12px;border-radius:12px;background:transparent;color:inherit;cursor:pointer}
  .btn:hover{background:#1f1f23}
  .btn.primary{background:var(--accent);border-color:var(--accent);color:var(--ink)}
  .btn.danger{border-color:var(--danger);color:var(--danger)}
  .pill{display:inline-flex;gap:0;border:1px solid var(--border);border-radius:12px;overflow:hidden}
  .pill button{border:0;background:transparent;padding:8px 12px;color:inherit;cursor:pointer}
  .pill button.active{background:var(--accent);color:var(--ink)}
  label{font-size:13px;display:block;margin-bottom:6px}
  input, select, textarea{width:100%;border:1px solid var(--border);background:transparent;color:inherit;padding:8px 10px;border-radius:12px}
  textarea{min-height:64px;resize:vertical}
  .muted{color:var(--fg-dim);font-size:12px}
  svg{max-width:100%;height:auto;display:block;touch-action: none}
  .results{display:grid;grid-template-columns:repeat(auto-fit,minmax(260px,1fr));gap:12px;padding-bottom:6px}
  .result{border:1px solid rgba(255,255,255,.07);border-radius:14px;padding:12px;background:rgba(255,255,255,.02)}
  .legend{display:flex;flex-wrap:wrap;gap:8px}
  .legend-item{display:inline-flex;align-items:center;gap:8px;font-size:12px;padding:6px 10px;border:1px solid rgba(255,255,255,.07);border-radius:999px;background:rgba(255,255,255,.03)}
  .swatch{width:14px;height:14px;border-radius:4px;border:1px solid var(--border)}
  .grid{display:grid;gap:10px}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .rowline{display:grid;grid-template-columns:28px 1.5fr 1fr 1fr 60px 60px 32px;gap:8px;align-items:center}
  .rowline input[type="color"]{padding:0;height:36px}
  .rowline .rm{justify-self:end}
  .bar{height:6px;background:#1f1f23;border-radius:6px;overflow:hidden}
  .bar>span{display:block;height:100%;background:var(--accent)}
  .note{font-size:12px;color:var(--fg-dim)}
  .section-title{font-size:14px;font-weight:700;margin:12px 0 6px}
  .tight{margin:6px 0}

  .hdr{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px}
  .map-toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .badge{border:1px solid var(--border);padding:4px 8px;border-radius:999px;font-size:12px}
  .hint{font-size:12px;color:var(--fg-dim);margin-top:6px}
  .gm-line{display:grid;grid-template-columns:110px 1fr;gap:8px;margin:4px 0}
  .gm-label{color:var(--fg-dim);font-size:12px}
  .gm-value{font-size:13px}

  /* current-position highlighting */
  .current-fill{pointer-events:none}
  .current-outline{fill:none;stroke:var(--accent);stroke-width:4;opacity:.85;pointer-events:none}
  .current-pulse{fill:none;stroke:var(--accent);stroke-width:6;stroke-opacity:.4;stroke-dasharray:10 12;pointer-events:none;animation:dash 2.6s linear infinite,fade 2.6s ease-in-out infinite}
  @keyframes dash{to{stroke-dashoffset:-44}}
  @keyframes fade{0%,100%{stroke-opacity:.15}50%{stroke-opacity:.55}}

  @media (max-width: 760px){ .grid2{grid-template-columns:1fr} .row{gap:12px} }


  .dirchip{display:inline-flex;align-items:center;justify-content:center;min-width:26px;height:22px;
           padding:0 8px;border:1px solid rgba(255,255,255,.18);border-radius:999px;font-size:12px;
           background:rgba(255,255,255,.05);margin-right:8px}
  .result{transition:box-shadow .2s,border-color .2s,background .2s}
  .result:hover{box-shadow:0 8px 24px rgba(0,0,0,.25);background:rgba(255,255,255,.04)}
  .result.hot{border-color:rgba(255,255,255,.35);box-shadow:0 10px 30px rgba(0,0,0,.35);background:rgba(255,255,255,.06)}


  /* Map height tuning */
  #mapSvg{height:420px}
  @media (max-width: 1200px){ #mapSvg{height:380px} }
  @media (max-width: 900px){ #mapSvg{height:340px} }
  @media (max-width: 700px){ #mapSvg{height:300px} }


  /* toast + (optional) wide map sizing kept minimal to avoid regressions */
  .toast-wrap{position:fixed;top:14px;right:14px;z-index:10000;display:flex;flex-direction:column;gap:8px}
  .toast{background:rgba(18,18,22,.88);border:1px solid var(--border);padding:10px 12px;border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.4)}
  .toast.danger{border-color:var(--danger);}

</style>
</head>
<body>
<div class="container">
  <div style="display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:14px">
    <div>
      <h1 style="margin:0;font-size:26px;letter-spacing:-0.02em">Hex Explorer</h1>
      <p class="sub" style="margin:4px 0 0">Explore adjacent hexes ‚Ä¢ GM details on click</p>
    </div>
    <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
      <input id="seed" type="text" placeholder="Seed (optional)" style="min-width:160px;flex:1 1 220px"/>
      <button class="btn" id="resetView" title="Recenter on current">üî≠ Reset View</button>
      <button class="btn" id="travelSelected" title="Travel to selected adjacent hex">üß≠ Travel to Selected</button>
      <span class="badge" id="posBadge">at (0,0)</span>
    </div>
  </div>

  <div class="row">
    <!-- LEFT: MAP AREA -->
    <div class="card" style="grid-column: 1 / -1;">
      <div class="hdr"><h2 style="margin:0">Map</h2><div class="badge" id="selBadge">no hex selected</div></div>
      <svg id="mapSvg" viewBox="0 0 1000 700" role="img" aria-label="Hex map" style="border-radius:12px"></svg>
      <div id="cards" class="results" style="margin-top:12px"></div>
      <div class="card" style="margin-top:12px">
        <h3 style="margin:0 0 8px">GM Details</h3>
        <div id="gmDetail" class="muted">Click a discovered hex to see expanded prompts and tables.</div>
      </div>

    </div>

    <!-- CONTROLS under map -->
    <div class="card" style="grid-column: 1 / -1;">
      <h2 style="margin:0 0 10px">Controls</h2>
      <div class="grid">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
          <label>Rolling Mode</label>
          <div class="pill">
            <button class="active" data-mode="d20">d20 Table</button>
            <button data-mode="weighted">Weighted</button>
          </div>
        </div>
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
          <label>Fog of War</label>
          <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
            <label class="tight"><input id="fogEnabled" type="checkbox"/> Enable</label>
            <div style="display:flex;align-items:center;gap:6px">
              <span class="muted" style="font-size:12px">Chance</span>
              <input id="fogChance" type="range" min="0" max="100" step="1" value="35" style="width:160px"/>
              <span id="fogPct" class="muted" style="min-width:36px;text-align:right">35%</span>
            </div>
          </div>
        </div>

        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
          <label>Visibility</label>
          <div class="pill">
            <button data-visibility="disadv">Disadv</button>
            <button class="active" data-visibility="normal">Normal</button>
            <button data-visibility="adv">Adv</button>
          </div>
        </div>
        <div style="display:flex;justify-content:space-between;align-items:center;gap:10px">
          <label>Orientation (fixed)</label>
          <div class="pill">
            <button class="active" data-orient="pointy">Pointy-top</button>
          </div>
        </div>

        <div class="grid2">
          <div>
            <label for="seed">Seed (optional)</label>
            <input id="seed" type="text" placeholder="e.g. session-12, map-A"/>
          </div>
        </div>
        <label class="tight"><input id="clarity" type="checkbox" checked/> Include Clarity (& Secondary on 6)</label>
        <label class="tight"><input id="wherein" type="checkbox" checked/> Include Where-in-Hex</label>

        <div>
          <button class="btn" id="clearRing">üßπ Clear Ring Cards</button>
        </div>
        <p class="muted">Tip: High vantage = roll twice, pick one. Dense canopy/night = roll twice, take lower.</p>
      </div>

      <h3 class="section-title">Config</h3>
      <div class="grid2">
        <button class="btn" id="loadBtn">üì• Load JSON</button>
        <button class="btn" id="saveBtn">üíæ Save JSON</button>
      </div>
      <input id="fileInput" type="file" accept="application/json" style="display:none"/>
      <button class="btn" id="resetBtn" style="margin-top:8px">‚§¥Ô∏é Reset Options to Defaults</button>
      <button class="btn danger" id="hardReset" style="margin-top:8px">üß® Hard Reset (clear cache)</button>
      <p class="note">Saving downloads <code>hex-visualizer-config.json</code>. Keep it next to this HTML and use ‚ÄúLoad JSON‚Äù later.</p>

      <h3 class="section-title">Legend</h3>
      <div id="legend" class="legend"></div>
    </div>

    <div class="card" style="grid-column: 1 / -1;">
<h2 style="margin:16px 0 10px">Options & Weights</h2>
      <div class="note" style="margin-bottom:8px">Weights are relative. Chances are normalized and shown live.</div>

      <div class="rowline muted" style="font-weight:700">
        <div>#</div><div>Label</div><div>Icon</div><div>Color</div><div>Weight</div><div>Chance</div><div></div>
      </div>
      <div id="optList"></div>

      <details style="margin-top:10px">
        <summary class="btn" style="display:inline-flex">‚ûï Add option</summary>
        <div class="grid2" style="margin-top:8px">
          <div>
            <label>Label</label>
            <input id="newLabel" placeholder="e.g. Ruin"/>
          </div>
          <div>
            <label>Icon (emoji)</label>
            <input id="newIcon" placeholder="üèöÔ∏è"/>
          </div>
          <div>
            <label>Color</label>
            <input id="newColor" type="color" value="#7c3aed"/>
          </div>
          <div>
            <label>Weight</label>
            <input id="newWeight" type="number" min="0" step="0.1" value="1"/>
          </div>
          <div style="grid-column: 1 / -1">
            <label>Description (what you see)</label>
            <textarea id="newDesc" placeholder="e.g. Ruin outline: arch, menhir ring, toppled tower, old wall line."></textarea>
          </div>
        </div>
        <button class="btn primary" id="addOption" style="margin-top:8px">Add</button>
      </details>
</div>
    </div>
  </div>
</div>

<script>
/* ---------------- Defaults ---------------- */
const DEFAULTS = [
  {id:"unknown",label:"Unknown",icon:"‚ùì",color:"#94a3b8",desc:"Nothing distinct; wavering horizon, indistinct shapes.",weight:1},
  {id:"trail",label:"Trail",icon:"üë£",color:"#8b5cf6",desc:"Trail sign at the border (ruts, prints, game path).",weight:1},
  {id:"smoke",label:"Smoke",icon:"üí®",color:"#9ca3af",desc:"Thin smoke/steam column: fire, forge, geyser, or vent.",weight:1},
  {id:"lights",label:"Lights",icon:"üî•",color:"#f59e0b",desc:"Lights after dusk (camp cluster, patrol lanterns, or eerie glows).",weight:1},
  {id:"water",label:"Water",icon:"üíß",color:"#3b82f6",desc:"Water glint or sound: river bend, spray of falls, or lake shine.",weight:1},
  {id:"ruin",label:"Ruin",icon:"üèöÔ∏è",color:"#7c3aed",desc:"Ruin outline: arch, menhir ring, toppled tower, old wall line.",weight:1},
  {id:"marker",label:"Marker",icon:"üö©",color:"#ef4444",desc:"Banner/totem/marker on a rise; faction sign, warning, or shrine.",weight:1},
  {id:"movement",label:"Herd/Caravan",icon:"ü¶å",color:"#22c55e",desc:"Moving mass: herd, caravan, warband; dust plume or trampled swath.",weight:1},
  {id:"earthworks",label:"Earthworks",icon:"‚õèÔ∏è",color:"#a16207",desc:"Fresh earth/clear-cut: dig site, logging, or burrow collapse.",weight:1},
  {id:"patrol",label:"Patrol",icon:"üõ°Ô∏è",color:"#64748b",desc:"Patrol/convoy in formation; regular spacing, glints of gear.",weight:1},
  {id:"weather",label:"Weather",icon:"‚õàÔ∏è",color:"#38bdf8",desc:"Weather boundary: storm wall, sudden snow line, or miasma bank.",weight:1},
  {id:"geomancy",label:"Stones",icon:"üóø",color:"#0ea5e9",desc:"Standing stones/geometry; ritual circle or survey obelisk.",weight:1},
  {id:"signal",label:"Signal",icon:"üì°",color:"#f97316",desc:"Signal: beacon flare, semaphore, mirrored flash, or smoke puffs.",weight:1},
  {id:"sky",label:"Sky sign",icon:"üïäÔ∏è",color:"#60a5fa",desc:"Sky sign: large bird/wyvern/skyship, cloud vortex, aurora ribbon.",weight:1},
  {id:"sound",label:"Sound",icon:"üîî",color:"#10b981",desc:"Sound carries: drums, chanting, machinery, distant bells.",weight:1},
  {id:"scent",label:"Scent",icon:"„Ä∞Ô∏è",color:"#0ea5a4",desc:"Scent carries: brine, incense, rot, ozone, woodsmoke.",weight:1},
  {id:"route",label:"Route",icon:"üõ§Ô∏è",color:"#a3e635",desc:"Route feature: road cut, switchback, ford, or rope bridge.",weight:1},
  {id:"settlement",label:"Settlement",icon:"üèòÔ∏è",color:"#f43f5e",desc:"Settlement edge: tilled fields, palisade line, rooftops, or piers.",weight:1},
  {id:"landmark",label:"Landmark",icon:"‚õ∞Ô∏è",color:"#a78bfa",desc:"Colossal landmark: titan bones, giant tree, or cliff carving.",weight:1},
  {id:"hazard",label:"Hazard",icon:"‚ö†Ô∏è",color:"#f59e0b",desc:"Immediate hazard: sinkhole, slide, lava tongue, waking colossus.",weight:1},
];

/* ---------------- State ---------------- */
const STORAGE_KEY = "hexviz.options.v2";
const state = {
  mode: "d20",
  visibility: "normal",
  orientation: "pointy",
  withClarity: true,
  withWhere: true,
  fogEnabled: false,
  fogChance: 35,
  seed: "",
  options: (function(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      const parsed = raw ? JSON.parse(raw) : null;
      if (Array.isArray(parsed) && parsed.length>0) return parsed;
    }catch(_){}
    return DEFAULTS.map(o=>({...o}));
  })(),
  current: {q:0, r:0},
  map: new Map(),
  selectedKey: null,
  view: {tx:500, ty:350, scale:1.0},
  results: []
};

/* ---------------- RNG ---------------- */
function mulberry32(seed){ return function(){ let t=(seed+=0x6d2b79f5); t=Math.imul(t^(t>>>15), t|1); t^=t+Math.imul(t^(t>>>7), t|61); return ((t^(t>>>14))>>>0)/4294967296; }; }
function seededRandom(seedStr){ if(!seedStr) return Math.random; let h=1779033703 ^ seedStr.length; for(let i=0;i<seedStr.length;i++){ h=Math.imul(h ^ seedStr.charCodeAt(i),3432918353); h=(h<<13)|(h>>>19);} return mulberry32(h>>>0); }
function rollDie(rng, n){ return Math.floor(rng()*n)+1; }
function rngFor(q,r){ const s = (state.seed||"") + "|" + q + "," + r; return seededRandom(s); }

/* ---------------- Hex math ---------------- */
function axialToPixel(q,r,size,orient){ return (orient==="pointy")
  ? [size*Math.sqrt(3)*(q+r/2), size*(3/2)*r]
  : [size*(3/2)*q, size*Math.sqrt(3)*(r+q/2)]; }
function neighborAxials(orient){ return (orient==="pointy")
  ? [[0,-1],[1,-1],[1,0],[0,1],[-1,1],[-1,0]]
  : [[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]]; }
function hexPath(cx,cy,size,orient){ const pts=[]; const start=(orient==="pointy")?-90:-60; for(let i=0;i<6;i++){ const a=(start+i*60)*Math.PI/180; pts.push([cx+size*Math.cos(a), cy+size*Math.sin(a)]); } return pts.map(([x,y])=>x.toFixed(1)+","+y.toFixed(1)).join(" "); }
function key(q,r){return q+","+r}
function parseKey(k){const [q,r]=k.split(",").map(Number); return {q,r}}

/* ---------------- Rolls & Tables ---------------- */
const WHERE_IN_HEX = ["At your border","Near edge","Mid-hex","Far side","High ground","Lowland / watercourse"];
function mapClarity(n){ if(n<=2) return "Vague silhouette (misread possible)"; if(n<=4) return "Partial detail"; if(n===5) return "Clear shape"; return "Revealing detail (also roll Secondary Cue)"; }
const SECONDARY = ["Birds scattering","Dropped kit/shell casing/tool","Fresh tracks/spoor","Blood/slick/ash fall","Heat shimmer / frost rime","Echoed voices","Faint glyph/residue","Cooking smell / odd perfume"];

function safeOptions(){ return (Array.isArray(state.options) && state.options.length>0) ? state.options : DEFAULTS; }

function weightedPick(rng, options){
  const src = (Array.isArray(options) && options.length>0) ? options : DEFAULTS;
  const pool = src.filter(o=>Number(o.weight)>0);
  const base = pool.length>0 ? pool : src;
  const total = base.reduce((s,o)=>s+Number(o.weight||0),0);
  if(total<=0){
    const idx = Math.floor(rng()*base.length);
    return base[idx] || DEFAULTS[0];
  }
  let t = rng()*total;
  for(const o of base){
    t -= Number(o.weight||0);
    if(t<=0) return o;
  }
  return base[base.length-1] || DEFAULTS[0];
}

function sightingFor(q,r){
  const rng = rngFor(q,r);
  let d20a = rollDie(rng,20), d20b = rollDie(rng,20), kept=d20a, other=d20b;
  if(state.visibility==="adv"){ kept=Math.max(d20a,d20b); other=(kept===d20a? d20b:d20a); }
  else if(state.visibility==="disadv"){ kept=Math.min(d20a,d20b); other=(kept===d20a? d20b:d20a); }
  else other=undefined;

  const arr = safeOptions();
  let picked;
  if(state.mode==="d20"){
    const idx = (kept-1) % arr.length;
    picked = arr[idx];
  }else{
    picked = weightedPick(rng, arr);
  }

  const res = {
    d20: kept, d20Other: other,
    option: JSON.parse(JSON.stringify(picked)),
    clarity:null, secondary:null, where:null,
    needsCloseApproach: state.visibility==="disadv" && kept<=2
  };
  if(state.withClarity){
    const c = rollDie(rng,6);
    res.clarity = {roll:c, text: mapClarity(c)};
    if(c===6){ const s=rollDie(rng,8); res.secondary={roll:s, text: SECONDARY[s-1]}; }
  }
  if(state.withWhere){ const w=rollDie(rng,6); res.where={roll:w, text: WHERE_IN_HEX[w-1]}; }
  return res;
}

/* ---------------- GM details ---------------- */
const GM_TABLES = {
  terrain: ["Broken plain","Scrub hills","Dense forest","Bog & fen","Volcanic shelf","High desert","Karst & sinkholes","Winding canyons","Alpine ridge","Coastal shelf"],
  approach: ["Tangled thorns","Loose scree","Slick mud","Braided streams","Sand drifts","Fallen trunks","Cramped ledges","Glass-like ice","Miasma pockets","Watchful sentries"],
  resident: ["Wandering merchants","Foraging predators","Hermit mystic","Survey crew","Bandits in hiding","Local militia patrol","Pilgrims on route","Burrowing colossi","Sky-raiders scouting","Nomad clan"],
  hook: ["Missing courier‚Äôs trail","Ransom exchange at dusk","Rumors of a hidden cache","A feud about to explode","A relic wanted by two factions","Strange dreams tied to this place","A map fragment surfaces","A guardian demands tribute","An omen carved into stone","A cursed object seeks a bearer"],
  resource: ["Medicinal herbs","Rare ore seam","Ancient timber","Crystal nodes","Freshwater spring","Fertile terrace","Beast nesting grounds","Ship-grade resin","Glow-moss & fungi","Amber deposits"],
  weather: ["Sudden squall line","High, desiccating winds","Ground fog by dawn","Charged auroras overhead","Stinging ashfall","Moth-thick night","Thunder rolling between ridges","Heat mirage windows","Fine ice needles","Biting salt spray"],
};
const THREAT_WORDS = ["Tranquil","Watchful","Unsettled","Perilous","Deadly"];

function gmDetailsFor(q,r, sight){
  const rng = rngFor(q,r);
  const pick = (arr)=> arr[Math.floor(rng()*arr.length)];
  const threat = 1 + Math.floor(rng()*5);
  const opt = sight.option?.id || "";
  let setpiece = "";
  if(opt==="ruin"){ setpiece = "Fragments of vaulted stone, vine-choked lintels, and a collapsed stair into dark."; }
  else if(opt==="water"){ setpiece = "Braided channels with slick boulders; a hush before falling water."; }
  else if(opt==="settlement"){ setpiece = "Field margins and smoke plumes; a palisade line just beyond a rise."; }
  else if(opt==="hazard"){ setpiece = "Fresh fissures and unstable ground; warning vibrations underfoot."; }
  else if(opt==="marker"){ setpiece = "Totem poles stacked with tokens; fresh paint and knotted charms."; }
  else if(opt==="geomancy"){ setpiece = "Standing stones keyed to geomagnetic lines; instruments hum faintly."; }
  else { setpiece = "A distinct feature commands attention, layered with older traces of passage."; }

  return {
    terrain: pick(GM_TABLES.terrain),
    approach: pick(GM_TABLES.approach),
    resident: pick(GM_TABLES.resident),
    hook: pick(GM_TABLES.hook),
    resource: pick(GM_TABLES.resource),
    weather: pick(GM_TABLES.weather),
    threat,
    threatWord: THREAT_WORDS[threat-1],
    setpiece,
  };
}


/* ---------------- Direction styles & hover linking ---------------- */
const DIR_COLORS = {NW:"#60a5fa", NE:"#34d399", E:"#f59e0b", SE:"#f87171", SW:"#a78bfa", W:"#22d3ee"};

function highlightHover(q,r,color){
  const g = document.getElementById("gMap"); if(!g) return;
  const old = document.getElementById("hoverOverlay"); if(old) old.remove();
  const svgNS="http://www.w3.org/2000/svg";
  const [px,py] = axialToPixel(q,r,size,state.orientation);
  const poly = document.createElementNS(svgNS,"polygon");
  poly.setAttribute("id","hoverOverlay");
  poly.setAttribute("points", hexPath(px,py,size*1.05,state.orientation));
  poly.setAttribute("fill","none");
  poly.setAttribute("stroke", color || "#fff");
  poly.setAttribute("stroke-width","3.5");
  poly.setAttribute("stroke-dasharray","4 6");
  g.appendChild(poly);
}
function clearHover(){
  const old = document.getElementById("hoverOverlay"); if(old) old.remove();
}
function highlightCardByKey(k, on, scroll=false){
  const el = document.querySelector(`.result[data-key="${CSS.escape(k)}"]`);
  if(!el) return;
  if(on){ el.classList.add("hot"); if(scroll) try{ el.scrollIntoView({block:"nearest", inline:"nearest", behavior:"smooth"});}catch(_){} }
  else el.classList.remove("hot");
}

/* ---------------- Map & exploration ---------------- */

/* Compute direction/color for immediate neighbors */
function getAdjDirection(q,r){
  const dirs = neighborAxials(state.orientation);
  for(let i=0;i<6;i++){
    const [dq,dr]=dirs[i];
    if(state.current.q + dq === q && state.current.r + dr === r){
      const d = dirName(i);
      return {dir:d, color: (DIR_COLORS && DIR_COLORS[d]) || "#ffffff"};
    }
  }
  return null;
}

const size = 48;
function neighborAxials(orient){ return (orient==="pointy")
  ? [[0,-1],[1,-1],[1,0],[0,1],[-1,1],[-1,0]]
  : [[0,-1],[1,0],[1,1],[0,1],[-1,0],[-1,-1]]; }


function ensureHex(q,r){
  const k = key(q,r);
  if(!state.map.has(k)){
    const sight = sightingFor(q,r);
    const details = gmDetailsFor(q,r, sight);
    state.map.set(k, {q,r, discovered:true, revealed:false, sight, details});
  }
  return state.map.get(k);
}




function discoverNeighborsFor(q,r){
  // Create six neighbors if missing and assign fog one-time at discovery (on travel).
  const dirs = neighborAxials(state.orientation);
  dirs.forEach(([dq,dr])=>{
    const nq = q + dq, nr = r + dr;
    const k = key(nq,nr);
    if(!state.map.has(k)){
      const sight = sightingFor(nq,nr);
      const details = gmDetailsFor(nq,nr, sight);
      let hiddenByFog = false;
      if(state.fogEnabled){
        const rng = rngFor(nq,nr);
        const roll = Math.floor(rng()*100); // 0..99
        hiddenByFog = roll < (Number(state.fogChance)||0);
      }
      state.map.set(k, {q:nq,r:nr, discovered:true, revealed:false, hiddenByFog, sight, details});
    }
  });
}

function generateNeighbors(){
  const dirs = neighborAxials(state.orientation);
  ensureHex(state.current.q, state.current.r);
  const results = [];
  dirs.forEach(([dq,dr],i)=>{
    const q = state.current.q + dq;
    const r = state.current.r + dr;
    const hex = ensureHex(q,r);
    // decide obscured (only if previously flagged on discovery)
    const obscured = !!hex.hiddenByFog && !hex.revealed;
    results.push({
      direction: dirName(i),
      q, r,
      option: hex.sight.option,
      d20: hex.sight.d20,
      d20Other: hex.sight.d20Other,
      clarity: hex.sight.clarity,
      secondary: hex.sight.secondary,
      where: hex.sight.where,
      needsCloseApproach: hex.sight.needsCloseApproach,
      obscured
    });
  });
  state.results = results;
  // quick lookup for hover highlighting
  state._adjMap = new Map(results.map(r=>[key(r.q,r.r), r]));
  renderCards();
  renderGM();
  updateToolbar();
}


/* ---------------- UI helpers ---------------- */
function el(tag, attrs={}, ...kids){
  const n=document.createElement(tag);
  for(const [k,v] of Object.entries(attrs||{})){
    if(k==="class") n.className=v;
    else if(k==="html") n.innerHTML=v;
    else if(k.startsWith("on") && typeof v==="function") n.addEventListener(k.substring(2), v);
    else n.setAttribute(k,v);
  }
  for(const kid of kids){ if(kid==null) continue; if(typeof kid==="string") n.appendChild(document.createTextNode(kid)); else n.appendChild(kid); }
  return n;
}

function renderLegend(){
  const L=document.getElementById("legend"); L.innerHTML="";
  safeOptions().forEach(o=>{
    const sw=el("span",{class:"swatch"}); sw.style.background=o.color;
    L.appendChild(el("div",{class:"legend-item"}, sw, `${o.icon} ${o.label}`));
  });
}

function renderOptions(){
  const wrap=document.getElementById("optList"); wrap.innerHTML="";
  const arr = safeOptions();
  const total = arr.reduce((s,o)=>s+Number(o.weight||0),0) || 1;
  arr.forEach((o,idx)=>{
    const chance = ((Number(o.weight||0)/total)*100)||0;
    const row = el("div",{class:"rowline"},
      el("div",{}, String(idx+1)),
      el("input",{value:o.label, oninput:(e)=>{o.label=e.target.value; persistConfig(); if(state.mode==="weighted"){ generateNeighbors(); } render();}}),
      el("input",{value:o.icon, oninput:(e)=>{o.icon=e.target.value; persistConfig(); if(state.mode==="weighted"){ generateNeighbors(); } render();}}),
      el("input",{type:"color", value:o.color, oninput:(e)=>{o.color=e.target.value; persistConfig(); if(state.mode==="weighted"){ generateNeighbors(); } render();}}),
      el("input",{type:"number",step:"0.1",min:"0",value:o.weight, oninput:(e)=>{o.weight=Number(e.target.value||0); persistConfig();
      // Update chance UI for this row only
      const arr = safeOptions();
      const pool = arr.filter(x=>Number(x.weight)>0);
      const base = pool.length>0 ? pool : arr;
      const total = base.reduce((s,x)=>s+Number(x.weight||0),0);
      const denom = total>0 ? total : (base.length||1);
      const numer = total>0 ? Number(o.weight||0) : (total===0? 1 : Number(o.weight||0));
      const pct = ((numer/denom)*100)||0;
      const row = e.target.closest(".rowline");
      if(row){ const bar=row.querySelector(".bar>span"); if(bar) bar.style.width = Math.min(pct,100)+"%"; const t=row.querySelector(".bar").nextElementSibling; if(t) t.textContent = pct.toFixed(1)+"%"; }
      if(state.mode==="weighted"){ generateNeighbors(); }
      renderCards();
    }}),
      el("div",{}, el("div",{class:"bar"}, el("span",{style:`width:${Math.min(chance,100)}%`})), el("div",{class:"muted"}, chance.toFixed(1)+"%")),
      el("button",{class:"btn rm", onclick:()=>{ if(safeOptions().length>1){ state.options.splice(idx,1); persistConfig(); if(state.mode==="weighted"){ generateNeighbors(); } render(); } }}, "üóëÔ∏è")
    );
    const desc = el("div",{}, el("textarea",{value:o.desc, oninput:(e)=>{o.desc=e.target.value; persistConfig();}}, ));
    wrap.appendChild(row);
    wrap.appendChild(desc);
  });
}

function dirName(i){
  const names = (state.orientation==="pointy")? ["NW","NE","E","SE","SW","W"] : ["NE","E","SE","SW","W","NW"];
  return names[i%6];
}


function renderCards(){
  const wrap=document.getElementById("cards"); wrap.innerHTML="";
  const arr = safeOptions();
  const pool = arr.filter(o=>Number(o.weight)>0);
  const base = pool.length>0 ? pool : arr;
  const total = base.reduce((s,o)=>s+Number(o.weight||0),0);
  const wmap = new Map(arr.map(o=>[o.id, Number(o.weight||0)]));
  const six = (state.results||[]).slice(0,6);
  six.forEach((r,i)=>{
    const denom = total>0 ? total : (base.length||1);
    const liveW = wmap.has(r.option.id) ? wmap.get(r.option.id) : Number(r.option.weight||0);
    const numer = total>0 ? liveW : 1;
    const chance = ((numer/denom)*100)||0;
    const dirColor = DIR_COLORS[r.direction] || "#94a3b8";
    const masked = r.obscured === true;
    const opt = masked ? {icon:"üå´Ô∏è", label:"Obscured", desc:"Hidden by fog. Travel to reveal.", color:"#94a3b8"} : r.option;
    const card=el("div",{class:"result", id:"card-"+i, "data-key":key(r.q,r.r), "data-dir": r.direction, style:`border-top:3px solid ${dirColor}`},
      el("div",{}, el("span",{class:"dirchip", style:`border-color:${dirColor};background:color-mix(in hsl, ${dirColor} 20%, transparent)`}, r.direction)),
      el("div",{style:"font-size:13px;margin-top:4px"}, `${opt.icon} ${opt.label}`),
      el("div",{class:"muted",style:"margin:6px 0 6px 0"}, masked
         ? "hidden by fog"
         : (state.mode==="d20" ? `d20=${r.d20}${r.d20Other?` (${state.visibility==="adv"?"adv":"disadv"} other ${r.d20Other})`:""}`
                               : `weighted pick ‚Ä¢ ~${chance.toFixed(1)}%`)),
      el("div",{}, opt.desc),
      (!masked && r.needsCloseApproach)? el("div",{class:"muted",style:"margin-top:6px"}, "Requires close approach (poor visibility)."): null,
      (!masked && r.clarity)? el("div",{class:"muted"}, `Clarity d6=${r.clarity.roll}: ${r.clarity.text}`): null,
      (!masked && r.secondary)? el("div",{class:"muted"}, `Secondary d8=${r.secondary.roll}: ${r.secondary.text}`): null,
      (!masked && r.where)? el("div",{class:"muted"}, `Where d6=${r.where.roll}: ${r.where.text}`): null
    );
    card.addEventListener("mouseenter", ()=>{ highlightHover(r.q,r.r, dirColor); highlightCardByKey(key(r.q,r.r), true); });
    card.addEventListener("mouseleave", ()=>{ clearHover(); highlightCardByKey(key(r.q,r.r), false); });
    card.addEventListener("click", ()=>{ state.selectedKey = key(r.q,r.r); renderGM(); updateToolbar(); highlightSelectedOnMap(); });
    wrap.appendChild(card);
  });
}



function renderGM(){
  const tgt = document.getElementById("gmDetail");
  const badge = document.getElementById("selBadge");
  if(!state.selectedKey){ tgt.innerHTML = "Click a discovered hex to see expanded prompts and tables."; badge.textContent="no hex selected"; return; }
  const {q,r} = parseKey(state.selectedKey);
  const hex = state.map.get(state.selectedKey);
  if(!hex){ tgt.innerHTML="(undiscovered)"; return; }
  badge.textContent = `selected (${q},${r})`;
  const adj = isAdjacentToCurrent(q,r);
  const travelHint = adj ? `<button class="btn primary" id="travelHereBtn">üß≠ Travel here</button>` : `<span class="muted">Select an adjacent hex to travel.</span>`;
  if(!hex.revealed && !(hex.q===state.current.q && hex.r===state.current.r)){
    tgt.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px">
        <div style="font-size:14px">üå´Ô∏è <strong>Obscured by fog</strong> <span class="muted">at</span> (${q},${r})</div>
        <div>${travelHint}</div>
      </div>
      <div class="muted">Travel into this hex to reveal its contents.</div>
    `;
  }else{
    const s = hex.sight;
    const d = hex.details;
    tgt.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;margin-bottom:8px">
        <div style="font-size:14px">${s.option.icon} <strong>${s.option.label}</strong> <span class="muted">at</span> (${q},${r})</div>
        <div>${travelHint}</div>
      </div>
      <div class="gm-line"><div class="gm-label">Setpiece</div><div class="gm-value">${d.setpiece}</div></div>
      <div class="gm-line"><div class="gm-label">Terrain</div><div class="gm-value">${d.terrain}</div></div>
      <div class="gm-line"><div class="gm-label">Approach</div><div class="gm-value">${d.approach}</div></div>
      <div class="gm-line"><div class="gm-label">Resident</div><div class="gm-value">${d.resident}</div></div>
      <div class="gm-line"><div class="gm-label">Hook</div><div class="gm-value">${d.hook}</div></div>
      <div class="gm-line"><div class="gm-label">Resource</div><div class="gm-value">${d.resource}</div></div>
      <div class="gm-line"><div class="gm-label">Weather</div><div class="gm-value">${d.weather}</div></div>
      <div class="gm-line"><div class="gm-label">Threat</div><div class="gm-value">${d.threat} <span class="muted">(${d.threatWord})</span></div></div>
      <div class="gm-line"><div class="gm-label">Clarity</div><div class="gm-value">${d.clarity}</div></div>
      <div class="gm-line"><div class="gm-label">Notes</div><div class="gm-value">${d.notes}</div></div>
    `;
  }
  const btn = document.getElementById("travelHereBtn");
  if(btn){
    btn.addEventListener("click", ()=>{
      state.current = {q,r};
      const h = ensureHex(q,r); h.revealed = true; state.map.set(key(q,r), h);
      state.selectedKey = key(q,r);
      document.getElementById("posBadge").textContent = `at (${q},${r})`;
      discoverNeighborsFor(q,r); generateNeighbors(); centerViewOn(q,r); render();
      if((h.sight?.option?.label||"").toLowerCase().includes("patrol")){ notify("You have moved into a Patrol hex!", "danger"); }
    });
  }
}


/* ---------------- Map rendering & pan/zoom ---------------- */
function isAdjacentToCurrent(q,r){
  const dirs = neighborAxials(state.orientation);
  return dirs.some(([dq,dr]) => (state.current.q+dq===q && state.current.r+dr===r));
}
function centerViewOn(q,r){
  const svg = document.getElementById("mapSvg");
  const W = svg.viewBox.baseVal.width, H = svg.viewBox.baseVal.height;
  const [x,y] = axialToPixel(q,r,size,state.orientation);
  state.view.tx = W/2 - x*state.view.scale;
  state.view.ty = H/2 - y*state.view.scale;
  applyView();
}
function applyView(){
  const g = document.getElementById("gMap");
  if(g) g.setAttribute("transform", `translate(${state.view.tx},${state.view.ty}) scale(${state.view.scale})`);
}




function renderMap(){
  const svgNS="http://www.w3.org/2000/svg";
  const svg=document.getElementById("mapSvg");
  svg.innerHTML="";
  const g = document.createElementNS(svgNS,"g");
  g.setAttribute("id","gMap");
  svg.appendChild(g);

  state.map.forEach((hex, k)=>{
    const [px,py] = axialToPixel(hex.q, hex.r, size, state.orientation);
    const poly = document.createElementNS(svgNS,"polygon");
    poly.setAttribute("points", hexPath(px,py,size,state.orientation));
    const col = hex.sight?.option?.color || "#94a3b8";

    // Mask ONLY current ring hexes when fog says they're obscured.
    const ringEntry = state._adjMap ? state._adjMap.get(k) : null;
    const masked = !!(ringEntry && ringEntry.obscured === true);

    poly.setAttribute("fill", masked ? "#ffffff0f" : (col + "33"));
    const adj = getAdjDirection(hex.q,hex.r);
    if(adj){ poly.setAttribute("stroke", adj.color); poly.setAttribute("stroke-width","3.5"); }
    else { poly.setAttribute("stroke", col + "99"); poly.setAttribute("stroke-width","1.5"); }
    poly.setAttribute("pointer-events","visiblePainted");
    poly.style.cursor = "pointer";
    poly.addEventListener("click", ()=>{ state.selectedKey = k; renderGM(); updateToolbar(); highlightSelectedOnMap(); });
    poly.addEventListener("mouseenter", ()=>{ const r = state._adjMap?.get(k); if(r){ highlightHover(r.q,r.r, DIR_COLORS[r.direction] || col); highlightCardByKey(k, true, true);} });
    poly.addEventListener("mouseleave", ()=>{ clearHover(); if(state._adjMap?.has(k)){ highlightCardByKey(k, false); } });
    g.appendChild(poly);

    const iconText=document.createElementNS(svgNS,"text");
    iconText.setAttribute("x",px); iconText.setAttribute("y",py+4);
    iconText.setAttribute("text-anchor","middle");
    iconText.setAttribute("font-size","16");
    iconText.setAttribute("fill","#fff");
    iconText.setAttribute("pointer-events","none");
    iconText.textContent = masked ? "Ôºü" : (hex.sight?.option?.icon || "‚ùì");
    g.appendChild(iconText);
  });

  const [cx,cy] = axialToPixel(state.current.q, state.current.r, size, state.orientation);
  const base = document.createElementNS(svgNS,"polygon");
  base.setAttribute("points", hexPath(cx,cy,size*0.9,state.orientation));
  base.setAttribute("class","current-fill");
  base.setAttribute("fill","#c4b5fd44");
  base.setAttribute("stroke","#a78bfa");
  base.setAttribute("stroke-width","3");
  base.setAttribute("pointer-events","none");
  g.appendChild(base);
  const outline = document.createElementNS(svgNS,"polygon");
  outline.setAttribute("points", hexPath(cx,cy,size*0.98,state.orientation));
  outline.setAttribute("class","current-outline");
  g.appendChild(outline);
  const pulse = document.createElementNS(svgNS,"polygon");
  pulse.setAttribute("points", hexPath(cx,cy,size*1.04,state.orientation));
  pulse.setAttribute("class","current-pulse");
  g.appendChild(pulse);

  applyView();
  highlightSelectedOnMap();
  document.getElementById("posBadge").textContent = `at (${state.current.q},${state.current.r})`;
}




function highlightSelectedOnMap(){
  const g = document.getElementById("gMap");
  if(!g) return;
  const old = document.getElementById("selOverlay");
  if(old) old.remove();
  if(!state.selectedKey) return;
  const {q,r} = parseKey(state.selectedKey);
  const [px,py] = axialToPixel(q,r,size,state.orientation);
  const svgNS="http://www.w3.org/2000/svg";
  const poly = document.createElementNS(svgNS,"polygon");
  poly.setAttribute("id","selOverlay");
  poly.setAttribute("points", hexPath(px,py,size*1.02,state.orientation));
  poly.setAttribute("fill","none");
  const info = getAdjDirection(q,r);
  poly.setAttribute("stroke", info ? info.color : "#ffffff");
  poly.setAttribute("stroke-width","3");
  poly.setAttribute("stroke-dasharray","6 6");
  g.appendChild(poly);
}

/* Pan/zoom with drag threshold */
(function attachPanZoom(){
  const svg = document.getElementById("mapSvg");
  let isPanning = false;
  let down = null;
  let last = null;
  const DRAG_THRESHOLD = 5;

  svg.addEventListener("pointerdown", (e)=>{
    down = {x:e.clientX, y:e.clientY};
    last = {x:e.clientX, y:e.clientY};
    isPanning = false;
  });

  svg.addEventListener("pointermove", (e)=>{
    if(!down) return;
    const dx = e.clientX - last.x;
    const dy = e.clientY - last.y;
    last = {x:e.clientX, y:e.clientY};

    if(!isPanning){
      const dist = Math.hypot(e.clientX - down.x, e.clientY - down.y);
      if(dist >= DRAG_THRESHOLD){
        isPanning = true;
        try { svg.setPointerCapture(e.pointerId); } catch(_){}
      } else {
        return;
      }
    }
    state.view.tx += dx;
    state.view.ty += dy;
    applyView();
  });

  function endPan(e){
    if(isPanning){
      try { svg.releasePointerCapture(e.pointerId); } catch(_){}
    }
    isPanning = false;
    down = null;
    last = null;
  }
  svg.addEventListener("pointerup", endPan);
  svg.addEventListener("pointercancel", endPan);

  svg.addEventListener("wheel", (e)=>{
    e.preventDefault();
    const scaleFactor = (e.deltaY<0) ? 1.1 : 0.9;
    const rect = svg.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const preX = (mx - state.view.tx)/state.view.scale;
    const preY = (my - state.view.ty)/state.view.scale;
    state.view.scale = Math.min(3, Math.max(0.4, state.view.scale*scaleFactor));
    state.view.tx = mx - preX*state.view.scale;
    state.view.ty = my - preY*state.view.scale;
    applyView();
  }, {passive:false});

  document.getElementById("resetView").addEventListener("click", ()=> centerViewOn(state.current.q, state.current.r));
})();

/* ---------------- Persistence ---------------- */
function persistConfig(){
  try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(state.options)); }catch(_){}
}
function saveJSON(){
  const payload = {version:2, options: state.options};
  const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = "hex-visualizer-config.json"; a.click();
  URL.revokeObjectURL(url);
}
function loadJSON(file){
  const reader = new FileReader();
  reader.onload = () => {
    try{
      const parsed = JSON.parse(reader.result);
      if(!parsed || !Array.isArray(parsed.options)) throw new Error("Invalid config format");
      state.options = parsed.options.map((o,i)=>({
        id: o.id || "opt"+i,
        label: String(o.label||"Option"),
        icon: String(o.icon||"‚ùì"),
        color: String(o.color||"#888888"),
        desc: String(o.desc||""),
        weight: Number(o.weight||0)
      }));
      persistConfig(); if(state.mode==="weighted"){ generateNeighbors(); } render();
    }catch(e){ alert("Could not load JSON: "+e.message); }
  };
  reader.readAsText(file);
}

/* ---------------- Toolbar & wiring ---------------- */
function updateToolbar(){
  const btn = document.getElementById("travelSelected");
  if(!btn) return;
  if(!state.selectedKey){ btn.disabled = true; btn.classList.remove("primary"); return; }
  const {q,r} = parseKey(state.selectedKey);
  if(isAdjacentToCurrent(q,r)){ btn.disabled = false; btn.classList.add("primary"); }
  else { btn.disabled = true; btn.classList.remove("primary"); }
}

document.getElementById("clearRing").addEventListener("click", ()=>{state.results=[]; renderCards();});
document.getElementById("saveBtn").addEventListener("click", saveJSON);
document.getElementById("loadBtn").addEventListener("click", ()=> document.getElementById("fileInput").click());
document.getElementById("fileInput").addEventListener("change", (e)=>{ if(e.target.files?.[0]) loadJSON(e.target.files[0]); e.target.value=""; });
document.getElementById("resetBtn").addEventListener("click", ()=>{ if(confirm("Reset options to defaults?")){ state.options = DEFAULTS.map(o=>({...o})); persistConfig(); if(state.mode==="weighted"){ generateNeighbors(); } render(); } });
document.getElementById("hardReset").addEventListener("click", ()=>{ if(confirm("Clear cached options and reload?")){ try{ localStorage.removeItem(STORAGE_KEY);}catch(_){ } location.reload(); } });

document.querySelectorAll("[data-visibility]").forEach(btn=>{
  btn.addEventListener("click", ()=>{ document.querySelectorAll("[data-visibility]").forEach(b=>b.classList.remove("active")); btn.classList.add("active"); state.visibility = btn.getAttribute("data-visibility"); generateNeighbors(); render(); });
});
document.querySelectorAll("[data-orient]").forEach(btn=>{
  btn.addEventListener("click", ()=>{ document.querySelectorAll("[data-orient]").forEach(b=>b.classList.remove("active")); btn.classList.add("active"); state.orientation = btn.getAttribute("data-orient"); generateNeighbors(); render(); });
});
document.querySelectorAll("[data-mode]").forEach(btn=>{
  btn.addEventListener("click", ()=>{ document.querySelectorAll("[data-mode]").forEach(b=>b.classList.remove("active")); btn.classList.add("active"); state.mode = btn.getAttribute("data-mode"); generateNeighbors(); render(); });
});

document.getElementById("seed").addEventListener("input", e=> {state.seed = e.target.value; });
document.getElementById("clarity").addEventListener("change", e=> {state.withClarity = e.target.checked; generateNeighbors(); render();});
document.getElementById("wherein").addEventListener("change", e=> {state.withWhere = e.target.checked; generateNeighbors(); render();});

document.getElementById("travelSelected").addEventListener("click", ()=>{
  if(!state.selectedKey) return;
  const {q,r} = parseKey(state.selectedKey);
  if(!isAdjacentToCurrent(q,r)) return;
  state.current = {q,r};
  const h = ensureHex(q,r); h.revealed = true; state.map.set(key(q,r), h);
  state.selectedKey = key(q,r);
  document.getElementById("posBadge").textContent = `at (${q},${r})`;
  discoverNeighborsFor(q,r);
  generateNeighbors();
  centerViewOn(q,r);
  render();
  if((h.sight?.option?.label||"").toLowerCase().includes("patrol")){ notify("You have moved into a Patrol hex!", "danger"); }
});

/* ---------------- Render orchestration ---------------- */
function render(){
  renderLegend();
  renderOptions();
  renderMap();
  renderCards();
  renderGM();
  updateToolbar();
}

/* ---------------- Minimal, unconditional bootstrap ---------------- */
function ensureStart(){
  ensureHex(0,0);
  const origin = state.map.get(key(0,0)); if(origin){ origin.revealed = true; state.map.set(key(0,0), origin); }
  discoverNeighborsFor(0,0);
  generateNeighbors();
  centerViewOn(0,0);
  render();
}
ensureStart();

// --- Fog controls wiring / Toasts (minimal, non-invasive) ---
(function(){
  const fogEnabledEl = document.getElementById("fogEnabled");
  const fogChanceEl = document.getElementById("fogChance");
  const fogPctEl = document.getElementById("fogPct");
  if(fogEnabledEl && fogChanceEl && fogPctEl){
    // init from state
    fogEnabledEl.checked = !!state.fogEnabled;
    fogChanceEl.value = Number(state.fogChance)||0;
    fogPctEl.textContent = (Number(state.fogChance)||0) + "%";
    fogEnabledEl.addEventListener("change", ()=>{ state.fogEnabled = fogEnabledEl.checked; generateNeighbors(); renderCards(); renderMap(); });
    fogChanceEl.addEventListener("input", ()=>{ state.fogChance = Number(fogChanceEl.value)||0; fogPctEl.textContent = state.fogChance + "%"; generateNeighbors(); renderCards(); renderMap(); });
  }
})();

function notify(msg, level){
  const wrap = document.getElementById("toasts");
  if(!wrap){ alert(msg); return; }
  const el = document.createElement("div");
  el.className = "toast" + (level ? " " + level : "");
  el.textContent = msg;
  wrap.appendChild(el);
  setTimeout(()=>{ el.style.opacity="0"; el.style.transform="translateY(-4px)"; el.style.transition="all .4s ease"; }, 3000);
  setTimeout(()=>{ try{ wrap.removeChild(el); }catch(_){} }, 3600);
}

</script>
<div id="toasts" class="toast-wrap" aria-live="polite"></div>
</body>
</html>
